/***********************************************************************/
/*                                                                     */
/*  FILE        :Egg_Printer_rx62t.c                                   */
/*  DATE        :Wed, Jun 01, 2022                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX62T                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.51).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/

//#include "typedefine.h"
#ifdef __cplusplus
//#include <ios>                        // Remove the comment when you use ios
//_SINT ios_base::Init::init_cnt;       // Remove the comment when you use ios
#endif

void main(void);
#ifdef __cplusplus
extern "C"
{
    void abort(void);
}
#endif

// -----------------------------------------------------------------------------
// User include
#include <stdint.h>
#include <stdbool.h>
// User include

// -----------------------------------------------------------------------------
// User define
#define sci_rx_buffer_size 11
#define sci_tx_buffer_size 1
#define spi_buff_size 5
#define up_value 2200
// User define

// -----------------------------------------------------------------------------
// User typedef
typedef enum
{
    initial = 0x0,
    step = 0x1,
    pen_servo = 0x2,
    read = 0x3
} Selection;

typedef enum
{
    pen_step = 0,
    egg_step = 1
} Steps;

typedef enum
{
    pen_step_5160_Cmd_Mask = 3,
    egg_step_5160_Cmd_Mask = 7
} Command_Mask;

typedef union
{
    uint8_t sci_rx_buff[sci_rx_buffer_size];
    struct
    {
        unsigned selection : 2;
        unsigned dummy : 6;
        unsigned servo_value : 16;
    };
} User_Command;

typedef struct
{
    uint32_t *tx_ptr;
    uint32_t *rx_ptr;
    uint16_t size;
    Steps steps;
} Moter_Command;

typedef struct
{
    bool sci_rx_flag;
    bool sci_tx_flag;
    bool spi_flag;
    bool initial_flag;
    uint8_t verify_flag;
} Flag_Set;
// User typedef

// -----------------------------------------------------------------------------
// User variables
User_Command User_Cmd;
Moter_Command Motor_Cmd;
Selection latest_cmd = read;
Flag_Set All_Flag = {true, true, true, false, 1};

uint8_t sci_tx_buff[sci_tx_buffer_size] = {0};

uint8_t spi_verify_buff_pen[spi_buff_size] = {0};
uint8_t spi_verify_buff_egg[spi_buff_size] = {0};
uint32_t tmc5160_read_position[spi_buff_size] = {0x21, 0x00, 0x00, 0x00, 0x00};

uint16_t servo_verify_value, tgr_b_value, tgr_temp;

uint32_t spi_rx_buff[spi_buff_size] = {0};
uint32_t spi_tx_buff[spi_buff_size] = {0};
uint32_t tmc5160_initial[13][spi_buff_size] = {
    {0xEC, 0x00, 0x01, 0x00, 0xC3},
    {0x90, 0x00, 0x06, 0x06, 0x03},
    {0x91, 0x00, 0x00, 0x00, 0x0A},
    {0x80, 0x00, 0x00, 0x00, 0x04},
    {0x93, 0x00, 0x00, 0x01, 0xF4},

    {0xA4, 0x00, 0x00, 0x03, 0xE8},
    {0xA5, 0x00, 0x00, 0xC3, 0x50},
    {0xA6, 0x00, 0x00, 0x01, 0xF4},
    {0xA7, 0x00, 0x03, 0x0D, 0x40},
    {0xA8, 0x00, 0x00, 0x02, 0xBC},
    {0xAA, 0x00, 0x00, 0x05, 0x78},
    {0xAB, 0x00, 0x00, 0x00, 0x0A},
    {0xA0, 0x00, 0x00, 0x00, 0x00}};

uint32_t cmt_delay_cnt;
// User variables

// -----------------------------------------------------------------------------
// User Functions
bool R_PG_IO_PORT_Write_PA4(uint8_t data);
bool (*const Set_Pen_Step_EN)(uint8_t) = R_PG_IO_PORT_Write_PA4;

bool R_PG_IO_PORT_Write_PA5(uint8_t data);
bool (*const Set_Pen_Step_CSN)(uint8_t) = R_PG_IO_PORT_Write_PA5;

bool R_PG_IO_PORT_Write_P70(uint8_t data);
bool (*const Set_Egg_Step_EN)(uint8_t) = R_PG_IO_PORT_Write_P70;

bool R_PG_IO_PORT_Write_P71(uint8_t data);
bool (*const Set_Egg_Step_CSN)(uint8_t) = R_PG_IO_PORT_Write_P71;

void Delay_ms(uint32_t ms)
{
    cmt_delay_cnt = 0;
    R_PG_Timer_SetCounterValue_CMT_U0_C0(0);
    R_PG_Timer_Start_CMT_U0_C0();
    while (cmt_delay_cnt != ms)
        ;
    R_PG_Timer_StopModule_CMT_U0();
}

void Delay_5160()
{
    uint32_t delay_cnt;
    for (delay_cnt = 0; delay_cnt < 0xfff; delay_cnt++)
        ;
}

void Control_5160(Moter_Command *Motor_Cmd)
{
    switch (Motor_Cmd->steps)
    {
    case pen_step:
        Set_Pen_Step_CSN(1); // CSN HIGH
        Delay_5160();
        Set_Pen_Step_CSN(0); // CSN LOW
        Delay_5160();

        while (All_Flag.spi_flag == false)
            ;
        All_Flag.spi_flag = false;
        R_PG_RSPI_StartTransfer_C0(Motor_Cmd->tx_ptr, Motor_Cmd->rx_ptr, Motor_Cmd->size); // Send data

        Delay_5160();
        Set_Pen_Step_CSN(1); // CSN HIGH
        Delay_5160();
        break;

    case egg_step:
        Set_Egg_Step_CSN(1); // CSN HIGH
        Delay_5160();
        Set_Egg_Step_CSN(0); // CSN LOW
        Delay_5160();

        while (All_Flag.spi_flag == false)
            ;
        All_Flag.spi_flag = false;
        R_PG_RSPI_StartTransfer_C0(Motor_Cmd->tx_ptr, Motor_Cmd->rx_ptr, Motor_Cmd->size); // Send data

        Delay_5160();
        Set_Egg_Step_CSN(1); // CSN HIGH
        Delay_5160();
        break;
    }
}

void Init5160()
{
    int i;

    Set_Pen_Step_EN(0);
    Set_Egg_Step_EN(0);

    Delay_ms(1000);

    Motor_Cmd.size = spi_buff_size;
    Motor_Cmd.rx_ptr = spi_rx_buff;

    Motor_Cmd.steps = pen_step;
    for (i = 0; i < 13; i++) // Initial Cmd
    {
        Motor_Cmd.tx_ptr = tmc5160_initial[i];
        Control_5160(&Motor_Cmd);
    }

    Motor_Cmd.steps = egg_step;
    for (i = 0; i < 13; i++) // Initial Cmd
    {
        Motor_Cmd.tx_ptr = tmc5160_initial[i];
        Control_5160(&Motor_Cmd);
    }
}

void Init_ALL_motor()
{
    Init5160();
    R_PG_Timer_SetTGR_D_MTU_U0_C0(up_value);
    R_PG_Timer_StartCount_MTU_U0_C0();
}

void Send_Feedback()
{
    All_Flag.verify_flag = 0;
    switch (latest_cmd)
    {
    case step:
        Motor_Cmd.size = spi_buff_size;
        Motor_Cmd.rx_ptr = spi_rx_buff;
        Motor_Cmd.tx_ptr = tmc5160_read_position;

        Motor_Cmd.steps = pen_step;
        Control_5160(&Motor_Cmd);
        Control_5160(&Motor_Cmd);
        All_Flag.verify_flag = (spi_verify_buff_pen[1] == spi_rx_buff[1]);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_pen[2] == spi_rx_buff[2]);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_pen[3] == spi_rx_buff[3]);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_pen[4] == spi_rx_buff[4]);

        Motor_Cmd.steps = egg_step;
        Control_5160(&Motor_Cmd);
        Control_5160(&Motor_Cmd);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_egg[1] == spi_rx_buff[1]);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_egg[2] == spi_rx_buff[2]);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_egg[3] == spi_rx_buff[3]);
        All_Flag.verify_flag = All_Flag.verify_flag && (spi_verify_buff_egg[4] == spi_rx_buff[4]);
        break;

    case pen_servo:
        Delay_ms(100);
        All_Flag.verify_flag = 1;
        break;
    }
    sci_tx_buff[0] = All_Flag.verify_flag;

    while (All_Flag.sci_tx_flag == false)
        ;
    All_Flag.sci_tx_flag = false;
    R_PG_SCI_StartSending_C0(sci_tx_buff, sci_tx_buffer_size);
    Delay_ms(10);
}

int Excuting_Command()
{
    int i;

    if (User_Cmd.selection == initial)
    {
        if (All_Flag.initial_flag == false)
        {
            All_Flag.initial_flag = true;
            Init_ALL_motor();
        }
        else
        {
            Motor_Cmd.size = spi_buff_size;
            Motor_Cmd.rx_ptr = spi_rx_buff;
            Motor_Cmd.tx_ptr = spi_tx_buff;
            spi_tx_buff[0] = 0xAD;
            for (i = 1; i < spi_buff_size; i++)
                spi_tx_buff[i] = 0;

            R_PG_Timer_SetTGR_D_MTU_U0_C0(up_value);
            R_PG_Timer_StartCount_MTU_U0_C0();

            Motor_Cmd.steps = pen_step;
            Control_5160(&Motor_Cmd);

            Motor_Cmd.steps = egg_step;
            Control_5160(&Motor_Cmd);
        }
        return 0;
    }

    switch (User_Cmd.selection)
    {
    case step:
        latest_cmd = User_Cmd.selection;
        Motor_Cmd.size = spi_buff_size;
        Motor_Cmd.rx_ptr = spi_rx_buff;
        Motor_Cmd.tx_ptr = spi_tx_buff;
        spi_tx_buff[0] = 0xAD;

        Motor_Cmd.steps = pen_step;
        for (i = 1; i < spi_buff_size; i++)
            spi_tx_buff[i] = spi_verify_buff_pen[i] = User_Cmd.sci_rx_buff[i + pen_step_5160_Cmd_Mask - 1];
        Control_5160(&Motor_Cmd);

        Motor_Cmd.steps = egg_step;
        for (i = 1; i < spi_buff_size; i++)
            spi_tx_buff[i] = spi_verify_buff_egg[i] = User_Cmd.sci_rx_buff[i + egg_step_5160_Cmd_Mask - 1];
        Control_5160(&Motor_Cmd);
        break;

    case pen_servo:
        latest_cmd = User_Cmd.selection;
        servo_verify_value = User_Cmd.servo_value;
        R_PG_Timer_SetTGR_D_MTU_U0_C0(User_Cmd.servo_value);
        break;

    case read:
        Delay_ms(10);
        Send_Feedback();
        break;
    }
}
// User Functions

// -----------------------------------------------------------------------------
// Codes
void main(void)
{
    // Initial
    R_PG_Clock_Set();      // CLK
    R_PG_IO_PORT_Set_P7(); // GPIO
    R_PG_IO_PORT_Set_PA();
    R_PG_RSPI_Set_C0(); // SPI
    R_PG_RSPI_SetCommand_C0();
    R_PG_SCI_Set_C0();          // SCI
    R_PG_Timer_Set_MTU_U0_C0(); // MTU

    // Start
    Set_Pen_Step_EN(1);
    Set_Egg_Step_EN(1);
    while (All_Flag.sci_rx_flag == false)
        ;
    All_Flag.sci_rx_flag = false;
    R_PG_SCI_StartReceiving_C0(User_Cmd.sci_rx_buff, sci_rx_buffer_size);

    // Loop
    while (1)
    {
        if (All_Flag.sci_rx_flag)
        {
            All_Flag.sci_rx_flag = false;
            Excuting_Command();
            R_PG_SCI_StartReceiving_C0(User_Cmd.sci_rx_buff, sci_rx_buffer_size);
        }
    }
}
// Codes

// -----------------------------------------------------------------------------
// PDG2 Functions
void Sci0TrFunc() // SCI_TX
{
    All_Flag.sci_tx_flag = true;
}

void Sci0ReFunc() // SCI_RX
{
    All_Flag.sci_rx_flag = true;
}

void Spi0IntFunc() // SPI
{
    All_Flag.spi_flag = true;
}

void Cmt0IntFunc() // CMT
{
    cmt_delay_cnt = cmt_delay_cnt + 1;
}
// PDG2 Functions

#ifdef __cplusplus
void abort(void)
{
}
#endif
